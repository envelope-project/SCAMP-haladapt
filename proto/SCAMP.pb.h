// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SCAMP.proto

#ifndef PROTOBUF_SCAMP_2eproto__INCLUDED
#define PROTOBUF_SCAMP_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace SCAMP {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SCAMP_2eproto();
void protobuf_AssignDesc_SCAMP_2eproto();
void protobuf_ShutdownFile_SCAMP_2eproto();

class RepeatedUInt;
class RepeatedULong;
class RepeatedFloat;
class RepeatedDouble;
class ProfileData;
class Profile;
class SCAMPTileInfo;
class SCAMPArgs;

enum SCAMPProfileType {
  PROFILE_TYPE_INVALID = 0,
  PROFILE_TYPE_1NN_INDEX = 1,
  PROFILE_TYPE_SUM_THRESH = 2,
  PROFILE_TYPE_FREQUENCY_THRESH = 3,
  PROFILE_TYPE_KNN = 4,
  PROFILE_TYPE_1NN_MULTIDIM = 5
};
bool SCAMPProfileType_IsValid(int value);
const SCAMPProfileType SCAMPProfileType_MIN = PROFILE_TYPE_INVALID;
const SCAMPProfileType SCAMPProfileType_MAX = PROFILE_TYPE_1NN_MULTIDIM;
const int SCAMPProfileType_ARRAYSIZE = SCAMPProfileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SCAMPProfileType_descriptor();
inline const ::std::string& SCAMPProfileType_Name(SCAMPProfileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SCAMPProfileType_descriptor(), value);
}
inline bool SCAMPProfileType_Parse(
    const ::std::string& name, SCAMPProfileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SCAMPProfileType>(
    SCAMPProfileType_descriptor(), name, value);
}
enum SCAMPPrecisionType {
  PRECISION_INVALID = 0,
  PRECISION_SINGLE = 1,
  PRECISION_MIXED = 2,
  PRECISION_DOUBLE = 3
};
bool SCAMPPrecisionType_IsValid(int value);
const SCAMPPrecisionType SCAMPPrecisionType_MIN = PRECISION_INVALID;
const SCAMPPrecisionType SCAMPPrecisionType_MAX = PRECISION_DOUBLE;
const int SCAMPPrecisionType_ARRAYSIZE = SCAMPPrecisionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SCAMPPrecisionType_descriptor();
inline const ::std::string& SCAMPPrecisionType_Name(SCAMPPrecisionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SCAMPPrecisionType_descriptor(), value);
}
inline bool SCAMPPrecisionType_Parse(
    const ::std::string& name, SCAMPPrecisionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SCAMPPrecisionType>(
    SCAMPPrecisionType_descriptor(), name, value);
}
// ===================================================================

class RepeatedUInt : public ::google::protobuf::Message {
 public:
  RepeatedUInt();
  virtual ~RepeatedUInt();

  RepeatedUInt(const RepeatedUInt& from);

  inline RepeatedUInt& operator=(const RepeatedUInt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RepeatedUInt& default_instance();

  void Swap(RepeatedUInt* other);

  // implements Message ----------------------------------------------

  RepeatedUInt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RepeatedUInt& from);
  void MergeFrom(const RepeatedUInt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint32 value(int index) const;
  inline void set_value(int index, ::google::protobuf::uint32 value);
  inline void add_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:SCAMP.RepeatedUInt)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > value_;
  friend void  protobuf_AddDesc_SCAMP_2eproto();
  friend void protobuf_AssignDesc_SCAMP_2eproto();
  friend void protobuf_ShutdownFile_SCAMP_2eproto();

  void InitAsDefaultInstance();
  static RepeatedUInt* default_instance_;
};
// -------------------------------------------------------------------

class RepeatedULong : public ::google::protobuf::Message {
 public:
  RepeatedULong();
  virtual ~RepeatedULong();

  RepeatedULong(const RepeatedULong& from);

  inline RepeatedULong& operator=(const RepeatedULong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RepeatedULong& default_instance();

  void Swap(RepeatedULong* other);

  // implements Message ----------------------------------------------

  RepeatedULong* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RepeatedULong& from);
  void MergeFrom(const RepeatedULong& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint64 value(int index) const;
  inline void set_value(int index, ::google::protobuf::uint64 value);
  inline void add_value(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:SCAMP.RepeatedULong)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > value_;
  friend void  protobuf_AddDesc_SCAMP_2eproto();
  friend void protobuf_AssignDesc_SCAMP_2eproto();
  friend void protobuf_ShutdownFile_SCAMP_2eproto();

  void InitAsDefaultInstance();
  static RepeatedULong* default_instance_;
};
// -------------------------------------------------------------------

class RepeatedFloat : public ::google::protobuf::Message {
 public:
  RepeatedFloat();
  virtual ~RepeatedFloat();

  RepeatedFloat(const RepeatedFloat& from);

  inline RepeatedFloat& operator=(const RepeatedFloat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RepeatedFloat& default_instance();

  void Swap(RepeatedFloat* other);

  // implements Message ----------------------------------------------

  RepeatedFloat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RepeatedFloat& from);
  void MergeFrom(const RepeatedFloat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline float value(int index) const;
  inline void set_value(int index, float value);
  inline void add_value(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      value() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:SCAMP.RepeatedFloat)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > value_;
  friend void  protobuf_AddDesc_SCAMP_2eproto();
  friend void protobuf_AssignDesc_SCAMP_2eproto();
  friend void protobuf_ShutdownFile_SCAMP_2eproto();

  void InitAsDefaultInstance();
  static RepeatedFloat* default_instance_;
};
// -------------------------------------------------------------------

class RepeatedDouble : public ::google::protobuf::Message {
 public:
  RepeatedDouble();
  virtual ~RepeatedDouble();

  RepeatedDouble(const RepeatedDouble& from);

  inline RepeatedDouble& operator=(const RepeatedDouble& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RepeatedDouble& default_instance();

  void Swap(RepeatedDouble* other);

  // implements Message ----------------------------------------------

  RepeatedDouble* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RepeatedDouble& from);
  void MergeFrom(const RepeatedDouble& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value(int index) const;
  inline void set_value(int index, double value);
  inline void add_value(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      value() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:SCAMP.RepeatedDouble)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > value_;
  friend void  protobuf_AddDesc_SCAMP_2eproto();
  friend void protobuf_AssignDesc_SCAMP_2eproto();
  friend void protobuf_ShutdownFile_SCAMP_2eproto();

  void InitAsDefaultInstance();
  static RepeatedDouble* default_instance_;
};
// -------------------------------------------------------------------

class ProfileData : public ::google::protobuf::Message {
 public:
  ProfileData();
  virtual ~ProfileData();

  ProfileData(const ProfileData& from);

  inline ProfileData& operator=(const ProfileData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProfileData& default_instance();

  enum DataCase {
    kUint32Value = 1,
    kUint64Value = 2,
    kFloatValue = 3,
    kDoubleValue = 4,
    DATA_NOT_SET = 0,
  };

  void Swap(ProfileData* other);

  // implements Message ----------------------------------------------

  ProfileData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProfileData& from);
  void MergeFrom(const ProfileData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SCAMP.RepeatedUInt uint32_value = 1;
  inline bool has_uint32_value() const;
  inline void clear_uint32_value();
  static const int kUint32ValueFieldNumber = 1;
  inline const ::SCAMP::RepeatedUInt& uint32_value() const;
  inline ::SCAMP::RepeatedUInt* mutable_uint32_value();
  inline ::SCAMP::RepeatedUInt* release_uint32_value();
  inline void set_allocated_uint32_value(::SCAMP::RepeatedUInt* uint32_value);

  // optional .SCAMP.RepeatedULong uint64_value = 2;
  inline bool has_uint64_value() const;
  inline void clear_uint64_value();
  static const int kUint64ValueFieldNumber = 2;
  inline const ::SCAMP::RepeatedULong& uint64_value() const;
  inline ::SCAMP::RepeatedULong* mutable_uint64_value();
  inline ::SCAMP::RepeatedULong* release_uint64_value();
  inline void set_allocated_uint64_value(::SCAMP::RepeatedULong* uint64_value);

  // optional .SCAMP.RepeatedFloat float_value = 3;
  inline bool has_float_value() const;
  inline void clear_float_value();
  static const int kFloatValueFieldNumber = 3;
  inline const ::SCAMP::RepeatedFloat& float_value() const;
  inline ::SCAMP::RepeatedFloat* mutable_float_value();
  inline ::SCAMP::RepeatedFloat* release_float_value();
  inline void set_allocated_float_value(::SCAMP::RepeatedFloat* float_value);

  // optional .SCAMP.RepeatedDouble double_value = 4;
  inline bool has_double_value() const;
  inline void clear_double_value();
  static const int kDoubleValueFieldNumber = 4;
  inline const ::SCAMP::RepeatedDouble& double_value() const;
  inline ::SCAMP::RepeatedDouble* mutable_double_value();
  inline ::SCAMP::RepeatedDouble* release_double_value();
  inline void set_allocated_double_value(::SCAMP::RepeatedDouble* double_value);

  inline DataCase Data_case() const;
  // @@protoc_insertion_point(class_scope:SCAMP.ProfileData)
 private:
  inline void set_has_uint32_value();
  inline void set_has_uint64_value();
  inline void set_has_float_value();
  inline void set_has_double_value();

  inline bool has_Data();
  void clear_Data();
  inline void clear_has_Data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union DataUnion {
    ::SCAMP::RepeatedUInt* uint32_value_;
    ::SCAMP::RepeatedULong* uint64_value_;
    ::SCAMP::RepeatedFloat* float_value_;
    ::SCAMP::RepeatedDouble* double_value_;
  } Data_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_SCAMP_2eproto();
  friend void protobuf_AssignDesc_SCAMP_2eproto();
  friend void protobuf_ShutdownFile_SCAMP_2eproto();

  void InitAsDefaultInstance();
  static ProfileData* default_instance_;
};
// -------------------------------------------------------------------

class Profile : public ::google::protobuf::Message {
 public:
  Profile();
  virtual ~Profile();

  Profile(const Profile& from);

  inline Profile& operator=(const Profile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Profile& default_instance();

  void Swap(Profile* other);

  // implements Message ----------------------------------------------

  Profile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Profile& from);
  void MergeFrom(const Profile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SCAMP.ProfileData data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::SCAMP::ProfileData& data(int index) const;
  inline ::SCAMP::ProfileData* mutable_data(int index);
  inline ::SCAMP::ProfileData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::SCAMP::ProfileData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::SCAMP::ProfileData >*
      mutable_data();

  // optional .SCAMP.SCAMPProfileType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::SCAMP::SCAMPProfileType type() const;
  inline void set_type(::SCAMP::SCAMPProfileType value);

  // @@protoc_insertion_point(class_scope:SCAMP.Profile)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SCAMP::ProfileData > data_;
  int type_;
  friend void  protobuf_AddDesc_SCAMP_2eproto();
  friend void protobuf_AssignDesc_SCAMP_2eproto();
  friend void protobuf_ShutdownFile_SCAMP_2eproto();

  void InitAsDefaultInstance();
  static Profile* default_instance_;
};
// -------------------------------------------------------------------

class SCAMPTileInfo : public ::google::protobuf::Message {
 public:
  SCAMPTileInfo();
  virtual ~SCAMPTileInfo();

  SCAMPTileInfo(const SCAMPTileInfo& from);

  inline SCAMPTileInfo& operator=(const SCAMPTileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCAMPTileInfo& default_instance();

  void Swap(SCAMPTileInfo* other);

  // implements Message ----------------------------------------------

  SCAMPTileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCAMPTileInfo& from);
  void MergeFrom(const SCAMPTileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SCAMP.SCAMPTileInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_SCAMP_2eproto();
  friend void protobuf_AssignDesc_SCAMP_2eproto();
  friend void protobuf_ShutdownFile_SCAMP_2eproto();

  void InitAsDefaultInstance();
  static SCAMPTileInfo* default_instance_;
};
// -------------------------------------------------------------------

class SCAMPArgs : public ::google::protobuf::Message {
 public:
  SCAMPArgs();
  virtual ~SCAMPArgs();

  SCAMPArgs(const SCAMPArgs& from);

  inline SCAMPArgs& operator=(const SCAMPArgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCAMPArgs& default_instance();

  void Swap(SCAMPArgs* other);

  // implements Message ----------------------------------------------

  SCAMPArgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCAMPArgs& from);
  void MergeFrom(const SCAMPArgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double timeseries_a = 1;
  inline int timeseries_a_size() const;
  inline void clear_timeseries_a();
  static const int kTimeseriesAFieldNumber = 1;
  inline double timeseries_a(int index) const;
  inline void set_timeseries_a(int index, double value);
  inline void add_timeseries_a(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      timeseries_a() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_timeseries_a();

  // repeated double timeseries_b = 2;
  inline int timeseries_b_size() const;
  inline void clear_timeseries_b();
  static const int kTimeseriesBFieldNumber = 2;
  inline double timeseries_b(int index) const;
  inline void set_timeseries_b(int index, double value);
  inline void add_timeseries_b(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      timeseries_b() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_timeseries_b();

  // optional .SCAMP.Profile profile_a = 3;
  inline bool has_profile_a() const;
  inline void clear_profile_a();
  static const int kProfileAFieldNumber = 3;
  inline const ::SCAMP::Profile& profile_a() const;
  inline ::SCAMP::Profile* mutable_profile_a();
  inline ::SCAMP::Profile* release_profile_a();
  inline void set_allocated_profile_a(::SCAMP::Profile* profile_a);

  // optional .SCAMP.Profile profile_b = 4;
  inline bool has_profile_b() const;
  inline void clear_profile_b();
  static const int kProfileBFieldNumber = 4;
  inline const ::SCAMP::Profile& profile_b() const;
  inline ::SCAMP::Profile* mutable_profile_b();
  inline ::SCAMP::Profile* release_profile_b();
  inline void set_allocated_profile_b(::SCAMP::Profile* profile_b);

  // optional bool has_b = 5;
  inline bool has_has_b() const;
  inline void clear_has_b();
  static const int kHasBFieldNumber = 5;
  inline bool has_b() const;
  inline void set_has_b(bool value);

  // optional uint64 window = 6;
  inline bool has_window() const;
  inline void clear_window();
  static const int kWindowFieldNumber = 6;
  inline ::google::protobuf::uint64 window() const;
  inline void set_window(::google::protobuf::uint64 value);

  // optional uint64 max_tile_size = 7;
  inline bool has_max_tile_size() const;
  inline void clear_max_tile_size();
  static const int kMaxTileSizeFieldNumber = 7;
  inline ::google::protobuf::uint64 max_tile_size() const;
  inline void set_max_tile_size(::google::protobuf::uint64 value);

  // optional int64 distributed_start_row = 8;
  inline bool has_distributed_start_row() const;
  inline void clear_distributed_start_row();
  static const int kDistributedStartRowFieldNumber = 8;
  inline ::google::protobuf::int64 distributed_start_row() const;
  inline void set_distributed_start_row(::google::protobuf::int64 value);

  // optional int64 distributed_start_col = 9;
  inline bool has_distributed_start_col() const;
  inline void clear_distributed_start_col();
  static const int kDistributedStartColFieldNumber = 9;
  inline ::google::protobuf::int64 distributed_start_col() const;
  inline void set_distributed_start_col(::google::protobuf::int64 value);

  // optional double distance_threshold = 10;
  inline bool has_distance_threshold() const;
  inline void clear_distance_threshold();
  static const int kDistanceThresholdFieldNumber = 10;
  inline double distance_threshold() const;
  inline void set_distance_threshold(double value);

  // optional .SCAMP.SCAMPPrecisionType precision_type = 11;
  inline bool has_precision_type() const;
  inline void clear_precision_type();
  static const int kPrecisionTypeFieldNumber = 11;
  inline ::SCAMP::SCAMPPrecisionType precision_type() const;
  inline void set_precision_type(::SCAMP::SCAMPPrecisionType value);

  // optional .SCAMP.SCAMPProfileType profile_type = 12;
  inline bool has_profile_type() const;
  inline void clear_profile_type();
  static const int kProfileTypeFieldNumber = 12;
  inline ::SCAMP::SCAMPProfileType profile_type() const;
  inline void set_profile_type(::SCAMP::SCAMPProfileType value);

  // optional bool computing_rows = 13;
  inline bool has_computing_rows() const;
  inline void clear_computing_rows();
  static const int kComputingRowsFieldNumber = 13;
  inline bool computing_rows() const;
  inline void set_computing_rows(bool value);

  // optional bool computing_columns = 14;
  inline bool has_computing_columns() const;
  inline void clear_computing_columns();
  static const int kComputingColumnsFieldNumber = 14;
  inline bool computing_columns() const;
  inline void set_computing_columns(bool value);

  // optional bool keep_rows_separate = 15;
  inline bool has_keep_rows_separate() const;
  inline void clear_keep_rows_separate();
  static const int kKeepRowsSeparateFieldNumber = 15;
  inline bool keep_rows_separate() const;
  inline void set_keep_rows_separate(bool value);

  // optional bool is_aligned = 16;
  inline bool has_is_aligned() const;
  inline void clear_is_aligned();
  static const int kIsAlignedFieldNumber = 16;
  inline bool is_aligned() const;
  inline void set_is_aligned(bool value);

  // @@protoc_insertion_point(class_scope:SCAMP.SCAMPArgs)
 private:
  inline void set_has_profile_a();
  inline void clear_has_profile_a();
  inline void set_has_profile_b();
  inline void clear_has_profile_b();
  inline void set_has_has_b();
  inline void clear_has_has_b();
  inline void set_has_window();
  inline void clear_has_window();
  inline void set_has_max_tile_size();
  inline void clear_has_max_tile_size();
  inline void set_has_distributed_start_row();
  inline void clear_has_distributed_start_row();
  inline void set_has_distributed_start_col();
  inline void clear_has_distributed_start_col();
  inline void set_has_distance_threshold();
  inline void clear_has_distance_threshold();
  inline void set_has_precision_type();
  inline void clear_has_precision_type();
  inline void set_has_profile_type();
  inline void clear_has_profile_type();
  inline void set_has_computing_rows();
  inline void clear_has_computing_rows();
  inline void set_has_computing_columns();
  inline void clear_has_computing_columns();
  inline void set_has_keep_rows_separate();
  inline void clear_has_keep_rows_separate();
  inline void set_has_is_aligned();
  inline void clear_has_is_aligned();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > timeseries_a_;
  ::google::protobuf::RepeatedField< double > timeseries_b_;
  ::SCAMP::Profile* profile_a_;
  ::SCAMP::Profile* profile_b_;
  ::google::protobuf::uint64 window_;
  ::google::protobuf::uint64 max_tile_size_;
  ::google::protobuf::int64 distributed_start_row_;
  ::google::protobuf::int64 distributed_start_col_;
  double distance_threshold_;
  int precision_type_;
  bool has_b_;
  bool computing_rows_;
  bool computing_columns_;
  bool keep_rows_separate_;
  int profile_type_;
  bool is_aligned_;
  friend void  protobuf_AddDesc_SCAMP_2eproto();
  friend void protobuf_AssignDesc_SCAMP_2eproto();
  friend void protobuf_ShutdownFile_SCAMP_2eproto();

  void InitAsDefaultInstance();
  static SCAMPArgs* default_instance_;
};
// ===================================================================


// ===================================================================

// RepeatedUInt

// repeated uint32 value = 1;
inline int RepeatedUInt::value_size() const {
  return value_.size();
}
inline void RepeatedUInt::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint32 RepeatedUInt::value(int index) const {
  // @@protoc_insertion_point(field_get:SCAMP.RepeatedUInt.value)
  return value_.Get(index);
}
inline void RepeatedUInt::set_value(int index, ::google::protobuf::uint32 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMP.RepeatedUInt.value)
}
inline void RepeatedUInt::add_value(::google::protobuf::uint32 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMP.RepeatedUInt.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RepeatedUInt::value() const {
  // @@protoc_insertion_point(field_list:SCAMP.RepeatedUInt.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RepeatedUInt::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:SCAMP.RepeatedUInt.value)
  return &value_;
}

// -------------------------------------------------------------------

// RepeatedULong

// repeated uint64 value = 1;
inline int RepeatedULong::value_size() const {
  return value_.size();
}
inline void RepeatedULong::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint64 RepeatedULong::value(int index) const {
  // @@protoc_insertion_point(field_get:SCAMP.RepeatedULong.value)
  return value_.Get(index);
}
inline void RepeatedULong::set_value(int index, ::google::protobuf::uint64 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMP.RepeatedULong.value)
}
inline void RepeatedULong::add_value(::google::protobuf::uint64 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMP.RepeatedULong.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
RepeatedULong::value() const {
  // @@protoc_insertion_point(field_list:SCAMP.RepeatedULong.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
RepeatedULong::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:SCAMP.RepeatedULong.value)
  return &value_;
}

// -------------------------------------------------------------------

// RepeatedFloat

// repeated float value = 1;
inline int RepeatedFloat::value_size() const {
  return value_.size();
}
inline void RepeatedFloat::clear_value() {
  value_.Clear();
}
inline float RepeatedFloat::value(int index) const {
  // @@protoc_insertion_point(field_get:SCAMP.RepeatedFloat.value)
  return value_.Get(index);
}
inline void RepeatedFloat::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMP.RepeatedFloat.value)
}
inline void RepeatedFloat::add_value(float value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMP.RepeatedFloat.value)
}
inline const ::google::protobuf::RepeatedField< float >&
RepeatedFloat::value() const {
  // @@protoc_insertion_point(field_list:SCAMP.RepeatedFloat.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
RepeatedFloat::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:SCAMP.RepeatedFloat.value)
  return &value_;
}

// -------------------------------------------------------------------

// RepeatedDouble

// repeated double value = 1;
inline int RepeatedDouble::value_size() const {
  return value_.size();
}
inline void RepeatedDouble::clear_value() {
  value_.Clear();
}
inline double RepeatedDouble::value(int index) const {
  // @@protoc_insertion_point(field_get:SCAMP.RepeatedDouble.value)
  return value_.Get(index);
}
inline void RepeatedDouble::set_value(int index, double value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMP.RepeatedDouble.value)
}
inline void RepeatedDouble::add_value(double value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMP.RepeatedDouble.value)
}
inline const ::google::protobuf::RepeatedField< double >&
RepeatedDouble::value() const {
  // @@protoc_insertion_point(field_list:SCAMP.RepeatedDouble.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
RepeatedDouble::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:SCAMP.RepeatedDouble.value)
  return &value_;
}

// -------------------------------------------------------------------

// ProfileData

// optional .SCAMP.RepeatedUInt uint32_value = 1;
inline bool ProfileData::has_uint32_value() const {
  return Data_case() == kUint32Value;
}
inline void ProfileData::set_has_uint32_value() {
  _oneof_case_[0] = kUint32Value;
}
inline void ProfileData::clear_uint32_value() {
  if (has_uint32_value()) {
    delete Data_.uint32_value_;
    clear_has_Data();
  }
}
inline const ::SCAMP::RepeatedUInt& ProfileData::uint32_value() const {
  return has_uint32_value() ? *Data_.uint32_value_
                      : ::SCAMP::RepeatedUInt::default_instance();
}
inline ::SCAMP::RepeatedUInt* ProfileData::mutable_uint32_value() {
  if (!has_uint32_value()) {
    clear_Data();
    set_has_uint32_value();
    Data_.uint32_value_ = new ::SCAMP::RepeatedUInt;
  }
  return Data_.uint32_value_;
}
inline ::SCAMP::RepeatedUInt* ProfileData::release_uint32_value() {
  if (has_uint32_value()) {
    clear_has_Data();
    ::SCAMP::RepeatedUInt* temp = Data_.uint32_value_;
    Data_.uint32_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ProfileData::set_allocated_uint32_value(::SCAMP::RepeatedUInt* uint32_value) {
  clear_Data();
  if (uint32_value) {
    set_has_uint32_value();
    Data_.uint32_value_ = uint32_value;
  }
}

// optional .SCAMP.RepeatedULong uint64_value = 2;
inline bool ProfileData::has_uint64_value() const {
  return Data_case() == kUint64Value;
}
inline void ProfileData::set_has_uint64_value() {
  _oneof_case_[0] = kUint64Value;
}
inline void ProfileData::clear_uint64_value() {
  if (has_uint64_value()) {
    delete Data_.uint64_value_;
    clear_has_Data();
  }
}
inline const ::SCAMP::RepeatedULong& ProfileData::uint64_value() const {
  return has_uint64_value() ? *Data_.uint64_value_
                      : ::SCAMP::RepeatedULong::default_instance();
}
inline ::SCAMP::RepeatedULong* ProfileData::mutable_uint64_value() {
  if (!has_uint64_value()) {
    clear_Data();
    set_has_uint64_value();
    Data_.uint64_value_ = new ::SCAMP::RepeatedULong;
  }
  return Data_.uint64_value_;
}
inline ::SCAMP::RepeatedULong* ProfileData::release_uint64_value() {
  if (has_uint64_value()) {
    clear_has_Data();
    ::SCAMP::RepeatedULong* temp = Data_.uint64_value_;
    Data_.uint64_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ProfileData::set_allocated_uint64_value(::SCAMP::RepeatedULong* uint64_value) {
  clear_Data();
  if (uint64_value) {
    set_has_uint64_value();
    Data_.uint64_value_ = uint64_value;
  }
}

// optional .SCAMP.RepeatedFloat float_value = 3;
inline bool ProfileData::has_float_value() const {
  return Data_case() == kFloatValue;
}
inline void ProfileData::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void ProfileData::clear_float_value() {
  if (has_float_value()) {
    delete Data_.float_value_;
    clear_has_Data();
  }
}
inline const ::SCAMP::RepeatedFloat& ProfileData::float_value() const {
  return has_float_value() ? *Data_.float_value_
                      : ::SCAMP::RepeatedFloat::default_instance();
}
inline ::SCAMP::RepeatedFloat* ProfileData::mutable_float_value() {
  if (!has_float_value()) {
    clear_Data();
    set_has_float_value();
    Data_.float_value_ = new ::SCAMP::RepeatedFloat;
  }
  return Data_.float_value_;
}
inline ::SCAMP::RepeatedFloat* ProfileData::release_float_value() {
  if (has_float_value()) {
    clear_has_Data();
    ::SCAMP::RepeatedFloat* temp = Data_.float_value_;
    Data_.float_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ProfileData::set_allocated_float_value(::SCAMP::RepeatedFloat* float_value) {
  clear_Data();
  if (float_value) {
    set_has_float_value();
    Data_.float_value_ = float_value;
  }
}

// optional .SCAMP.RepeatedDouble double_value = 4;
inline bool ProfileData::has_double_value() const {
  return Data_case() == kDoubleValue;
}
inline void ProfileData::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void ProfileData::clear_double_value() {
  if (has_double_value()) {
    delete Data_.double_value_;
    clear_has_Data();
  }
}
inline const ::SCAMP::RepeatedDouble& ProfileData::double_value() const {
  return has_double_value() ? *Data_.double_value_
                      : ::SCAMP::RepeatedDouble::default_instance();
}
inline ::SCAMP::RepeatedDouble* ProfileData::mutable_double_value() {
  if (!has_double_value()) {
    clear_Data();
    set_has_double_value();
    Data_.double_value_ = new ::SCAMP::RepeatedDouble;
  }
  return Data_.double_value_;
}
inline ::SCAMP::RepeatedDouble* ProfileData::release_double_value() {
  if (has_double_value()) {
    clear_has_Data();
    ::SCAMP::RepeatedDouble* temp = Data_.double_value_;
    Data_.double_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ProfileData::set_allocated_double_value(::SCAMP::RepeatedDouble* double_value) {
  clear_Data();
  if (double_value) {
    set_has_double_value();
    Data_.double_value_ = double_value;
  }
}

inline bool ProfileData::has_Data() {
  return Data_case() != DATA_NOT_SET;
}
inline void ProfileData::clear_has_Data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline ProfileData::DataCase ProfileData::Data_case() const {
  return ProfileData::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Profile

// repeated .SCAMP.ProfileData data = 1;
inline int Profile::data_size() const {
  return data_.size();
}
inline void Profile::clear_data() {
  data_.Clear();
}
inline const ::SCAMP::ProfileData& Profile::data(int index) const {
  // @@protoc_insertion_point(field_get:SCAMP.Profile.data)
  return data_.Get(index);
}
inline ::SCAMP::ProfileData* Profile::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:SCAMP.Profile.data)
  return data_.Mutable(index);
}
inline ::SCAMP::ProfileData* Profile::add_data() {
  // @@protoc_insertion_point(field_add:SCAMP.Profile.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SCAMP::ProfileData >&
Profile::data() const {
  // @@protoc_insertion_point(field_list:SCAMP.Profile.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::SCAMP::ProfileData >*
Profile::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:SCAMP.Profile.data)
  return &data_;
}

// optional .SCAMP.SCAMPProfileType type = 2;
inline bool Profile::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Profile::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Profile::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Profile::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SCAMP::SCAMPProfileType Profile::type() const {
  // @@protoc_insertion_point(field_get:SCAMP.Profile.type)
  return static_cast< ::SCAMP::SCAMPProfileType >(type_);
}
inline void Profile::set_type(::SCAMP::SCAMPProfileType value) {
  assert(::SCAMP::SCAMPProfileType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.Profile.type)
}

// -------------------------------------------------------------------

// SCAMPTileInfo

// -------------------------------------------------------------------

// SCAMPArgs

// repeated double timeseries_a = 1;
inline int SCAMPArgs::timeseries_a_size() const {
  return timeseries_a_.size();
}
inline void SCAMPArgs::clear_timeseries_a() {
  timeseries_a_.Clear();
}
inline double SCAMPArgs::timeseries_a(int index) const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.timeseries_a)
  return timeseries_a_.Get(index);
}
inline void SCAMPArgs::set_timeseries_a(int index, double value) {
  timeseries_a_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.timeseries_a)
}
inline void SCAMPArgs::add_timeseries_a(double value) {
  timeseries_a_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMP.SCAMPArgs.timeseries_a)
}
inline const ::google::protobuf::RepeatedField< double >&
SCAMPArgs::timeseries_a() const {
  // @@protoc_insertion_point(field_list:SCAMP.SCAMPArgs.timeseries_a)
  return timeseries_a_;
}
inline ::google::protobuf::RepeatedField< double >*
SCAMPArgs::mutable_timeseries_a() {
  // @@protoc_insertion_point(field_mutable_list:SCAMP.SCAMPArgs.timeseries_a)
  return &timeseries_a_;
}

// repeated double timeseries_b = 2;
inline int SCAMPArgs::timeseries_b_size() const {
  return timeseries_b_.size();
}
inline void SCAMPArgs::clear_timeseries_b() {
  timeseries_b_.Clear();
}
inline double SCAMPArgs::timeseries_b(int index) const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.timeseries_b)
  return timeseries_b_.Get(index);
}
inline void SCAMPArgs::set_timeseries_b(int index, double value) {
  timeseries_b_.Set(index, value);
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.timeseries_b)
}
inline void SCAMPArgs::add_timeseries_b(double value) {
  timeseries_b_.Add(value);
  // @@protoc_insertion_point(field_add:SCAMP.SCAMPArgs.timeseries_b)
}
inline const ::google::protobuf::RepeatedField< double >&
SCAMPArgs::timeseries_b() const {
  // @@protoc_insertion_point(field_list:SCAMP.SCAMPArgs.timeseries_b)
  return timeseries_b_;
}
inline ::google::protobuf::RepeatedField< double >*
SCAMPArgs::mutable_timeseries_b() {
  // @@protoc_insertion_point(field_mutable_list:SCAMP.SCAMPArgs.timeseries_b)
  return &timeseries_b_;
}

// optional .SCAMP.Profile profile_a = 3;
inline bool SCAMPArgs::has_profile_a() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SCAMPArgs::set_has_profile_a() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SCAMPArgs::clear_has_profile_a() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SCAMPArgs::clear_profile_a() {
  if (profile_a_ != NULL) profile_a_->::SCAMP::Profile::Clear();
  clear_has_profile_a();
}
inline const ::SCAMP::Profile& SCAMPArgs::profile_a() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.profile_a)
  return profile_a_ != NULL ? *profile_a_ : *default_instance_->profile_a_;
}
inline ::SCAMP::Profile* SCAMPArgs::mutable_profile_a() {
  set_has_profile_a();
  if (profile_a_ == NULL) profile_a_ = new ::SCAMP::Profile;
  // @@protoc_insertion_point(field_mutable:SCAMP.SCAMPArgs.profile_a)
  return profile_a_;
}
inline ::SCAMP::Profile* SCAMPArgs::release_profile_a() {
  clear_has_profile_a();
  ::SCAMP::Profile* temp = profile_a_;
  profile_a_ = NULL;
  return temp;
}
inline void SCAMPArgs::set_allocated_profile_a(::SCAMP::Profile* profile_a) {
  delete profile_a_;
  profile_a_ = profile_a;
  if (profile_a) {
    set_has_profile_a();
  } else {
    clear_has_profile_a();
  }
  // @@protoc_insertion_point(field_set_allocated:SCAMP.SCAMPArgs.profile_a)
}

// optional .SCAMP.Profile profile_b = 4;
inline bool SCAMPArgs::has_profile_b() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SCAMPArgs::set_has_profile_b() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SCAMPArgs::clear_has_profile_b() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SCAMPArgs::clear_profile_b() {
  if (profile_b_ != NULL) profile_b_->::SCAMP::Profile::Clear();
  clear_has_profile_b();
}
inline const ::SCAMP::Profile& SCAMPArgs::profile_b() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.profile_b)
  return profile_b_ != NULL ? *profile_b_ : *default_instance_->profile_b_;
}
inline ::SCAMP::Profile* SCAMPArgs::mutable_profile_b() {
  set_has_profile_b();
  if (profile_b_ == NULL) profile_b_ = new ::SCAMP::Profile;
  // @@protoc_insertion_point(field_mutable:SCAMP.SCAMPArgs.profile_b)
  return profile_b_;
}
inline ::SCAMP::Profile* SCAMPArgs::release_profile_b() {
  clear_has_profile_b();
  ::SCAMP::Profile* temp = profile_b_;
  profile_b_ = NULL;
  return temp;
}
inline void SCAMPArgs::set_allocated_profile_b(::SCAMP::Profile* profile_b) {
  delete profile_b_;
  profile_b_ = profile_b;
  if (profile_b) {
    set_has_profile_b();
  } else {
    clear_has_profile_b();
  }
  // @@protoc_insertion_point(field_set_allocated:SCAMP.SCAMPArgs.profile_b)
}

// optional bool has_b = 5;
inline bool SCAMPArgs::has_has_b() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SCAMPArgs::set_has_has_b() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SCAMPArgs::clear_has_has_b() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SCAMPArgs::clear_has_b() {
  has_b_ = false;
  clear_has_has_b();
}
inline bool SCAMPArgs::has_b() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.has_b)
  return has_b_;
}
inline void SCAMPArgs::set_has_b(bool value) {
  set_has_has_b();
  has_b_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.has_b)
}

// optional uint64 window = 6;
inline bool SCAMPArgs::has_window() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SCAMPArgs::set_has_window() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SCAMPArgs::clear_has_window() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SCAMPArgs::clear_window() {
  window_ = GOOGLE_ULONGLONG(0);
  clear_has_window();
}
inline ::google::protobuf::uint64 SCAMPArgs::window() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.window)
  return window_;
}
inline void SCAMPArgs::set_window(::google::protobuf::uint64 value) {
  set_has_window();
  window_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.window)
}

// optional uint64 max_tile_size = 7;
inline bool SCAMPArgs::has_max_tile_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SCAMPArgs::set_has_max_tile_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SCAMPArgs::clear_has_max_tile_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SCAMPArgs::clear_max_tile_size() {
  max_tile_size_ = GOOGLE_ULONGLONG(0);
  clear_has_max_tile_size();
}
inline ::google::protobuf::uint64 SCAMPArgs::max_tile_size() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.max_tile_size)
  return max_tile_size_;
}
inline void SCAMPArgs::set_max_tile_size(::google::protobuf::uint64 value) {
  set_has_max_tile_size();
  max_tile_size_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.max_tile_size)
}

// optional int64 distributed_start_row = 8;
inline bool SCAMPArgs::has_distributed_start_row() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SCAMPArgs::set_has_distributed_start_row() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SCAMPArgs::clear_has_distributed_start_row() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SCAMPArgs::clear_distributed_start_row() {
  distributed_start_row_ = GOOGLE_LONGLONG(0);
  clear_has_distributed_start_row();
}
inline ::google::protobuf::int64 SCAMPArgs::distributed_start_row() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.distributed_start_row)
  return distributed_start_row_;
}
inline void SCAMPArgs::set_distributed_start_row(::google::protobuf::int64 value) {
  set_has_distributed_start_row();
  distributed_start_row_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.distributed_start_row)
}

// optional int64 distributed_start_col = 9;
inline bool SCAMPArgs::has_distributed_start_col() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SCAMPArgs::set_has_distributed_start_col() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SCAMPArgs::clear_has_distributed_start_col() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SCAMPArgs::clear_distributed_start_col() {
  distributed_start_col_ = GOOGLE_LONGLONG(0);
  clear_has_distributed_start_col();
}
inline ::google::protobuf::int64 SCAMPArgs::distributed_start_col() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.distributed_start_col)
  return distributed_start_col_;
}
inline void SCAMPArgs::set_distributed_start_col(::google::protobuf::int64 value) {
  set_has_distributed_start_col();
  distributed_start_col_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.distributed_start_col)
}

// optional double distance_threshold = 10;
inline bool SCAMPArgs::has_distance_threshold() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SCAMPArgs::set_has_distance_threshold() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SCAMPArgs::clear_has_distance_threshold() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SCAMPArgs::clear_distance_threshold() {
  distance_threshold_ = 0;
  clear_has_distance_threshold();
}
inline double SCAMPArgs::distance_threshold() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.distance_threshold)
  return distance_threshold_;
}
inline void SCAMPArgs::set_distance_threshold(double value) {
  set_has_distance_threshold();
  distance_threshold_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.distance_threshold)
}

// optional .SCAMP.SCAMPPrecisionType precision_type = 11;
inline bool SCAMPArgs::has_precision_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SCAMPArgs::set_has_precision_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SCAMPArgs::clear_has_precision_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SCAMPArgs::clear_precision_type() {
  precision_type_ = 0;
  clear_has_precision_type();
}
inline ::SCAMP::SCAMPPrecisionType SCAMPArgs::precision_type() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.precision_type)
  return static_cast< ::SCAMP::SCAMPPrecisionType >(precision_type_);
}
inline void SCAMPArgs::set_precision_type(::SCAMP::SCAMPPrecisionType value) {
  assert(::SCAMP::SCAMPPrecisionType_IsValid(value));
  set_has_precision_type();
  precision_type_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.precision_type)
}

// optional .SCAMP.SCAMPProfileType profile_type = 12;
inline bool SCAMPArgs::has_profile_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SCAMPArgs::set_has_profile_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SCAMPArgs::clear_has_profile_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SCAMPArgs::clear_profile_type() {
  profile_type_ = 0;
  clear_has_profile_type();
}
inline ::SCAMP::SCAMPProfileType SCAMPArgs::profile_type() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.profile_type)
  return static_cast< ::SCAMP::SCAMPProfileType >(profile_type_);
}
inline void SCAMPArgs::set_profile_type(::SCAMP::SCAMPProfileType value) {
  assert(::SCAMP::SCAMPProfileType_IsValid(value));
  set_has_profile_type();
  profile_type_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.profile_type)
}

// optional bool computing_rows = 13;
inline bool SCAMPArgs::has_computing_rows() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SCAMPArgs::set_has_computing_rows() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SCAMPArgs::clear_has_computing_rows() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SCAMPArgs::clear_computing_rows() {
  computing_rows_ = false;
  clear_has_computing_rows();
}
inline bool SCAMPArgs::computing_rows() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.computing_rows)
  return computing_rows_;
}
inline void SCAMPArgs::set_computing_rows(bool value) {
  set_has_computing_rows();
  computing_rows_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.computing_rows)
}

// optional bool computing_columns = 14;
inline bool SCAMPArgs::has_computing_columns() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SCAMPArgs::set_has_computing_columns() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SCAMPArgs::clear_has_computing_columns() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SCAMPArgs::clear_computing_columns() {
  computing_columns_ = false;
  clear_has_computing_columns();
}
inline bool SCAMPArgs::computing_columns() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.computing_columns)
  return computing_columns_;
}
inline void SCAMPArgs::set_computing_columns(bool value) {
  set_has_computing_columns();
  computing_columns_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.computing_columns)
}

// optional bool keep_rows_separate = 15;
inline bool SCAMPArgs::has_keep_rows_separate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SCAMPArgs::set_has_keep_rows_separate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SCAMPArgs::clear_has_keep_rows_separate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SCAMPArgs::clear_keep_rows_separate() {
  keep_rows_separate_ = false;
  clear_has_keep_rows_separate();
}
inline bool SCAMPArgs::keep_rows_separate() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.keep_rows_separate)
  return keep_rows_separate_;
}
inline void SCAMPArgs::set_keep_rows_separate(bool value) {
  set_has_keep_rows_separate();
  keep_rows_separate_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.keep_rows_separate)
}

// optional bool is_aligned = 16;
inline bool SCAMPArgs::has_is_aligned() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SCAMPArgs::set_has_is_aligned() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SCAMPArgs::clear_has_is_aligned() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SCAMPArgs::clear_is_aligned() {
  is_aligned_ = false;
  clear_has_is_aligned();
}
inline bool SCAMPArgs::is_aligned() const {
  // @@protoc_insertion_point(field_get:SCAMP.SCAMPArgs.is_aligned)
  return is_aligned_;
}
inline void SCAMPArgs::set_is_aligned(bool value) {
  set_has_is_aligned();
  is_aligned_ = value;
  // @@protoc_insertion_point(field_set:SCAMP.SCAMPArgs.is_aligned)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SCAMP

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SCAMP::SCAMPProfileType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCAMP::SCAMPProfileType>() {
  return ::SCAMP::SCAMPProfileType_descriptor();
}
template <> struct is_proto_enum< ::SCAMP::SCAMPPrecisionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SCAMP::SCAMPPrecisionType>() {
  return ::SCAMP::SCAMPPrecisionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SCAMP_2eproto__INCLUDED
